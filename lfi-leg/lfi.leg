%{
#include <stdio.h>
#include <arm64.h>
#include <util.h>

typedef struct transform {
    char* val;
    char* guard;
    char* post;
} Transform;

static void
tfree(Transform t)
{
    free(t.val);
    free(t.guard);
    free(t.post);
}

// These functions are for the load/store rewriter.

static void
ldst(Transform l, Transform rt, Transform addr, bool isload)
{
    if (addr.guard)
        printf("%s\n", addr.guard);
    if (isload && isres(rt.val)) {
        printf("%s x22, %s\n", l.val, addr.val);
        printf("add %s, x21, w22, uxtw\n", rt.val);
    } else {
        printf("%s %s, %s\n", l.val, rt.val, addr.val);
    }
    if (addr.post)
        printf("%s\n", addr.post);
    tfree(l); tfree(rt); tfree(addr);
}

static void
ldstmulti(Transform l, Transform rt1, Transform rt2, Transform addr, bool isload)
{
    printf("%s\n", addr.guard);
    if (isload && (isres(rt1.val) || isres(rt2.val))) {
        printf("%s %s, %s, %s\n", l.val, rt1.val, rt2.val, addr.val);
        if (isres(rt1.val))
            printf("add %s, x21, %s, uxtw\n", rt2.val, lo(rt2.val));
        if (isres(rt2.val))
            printf("add %s, x21, %s, uxtw\n", rt2.val, lo(rt2.val));
    } else {
        printf("%s %s, %s, %s\n", l.val, rt1.val, rt2.val, addr.val);
    }
    if (addr.post)
        printf("%s\n", addr.post);
    tfree(l); tfree(rt1); tfree(rt2); tfree(addr);
}

#define YYSTYPE Transform
%}

Insn = INDENT Label? (
      LdSt
    | Branch
    | Syscall
    | ModSpecial
    | ModLR
    | Any
) COMMENT? EOL

COMMENT = '//' (!EOL .)*

INDENT = < [ \t]* > {
    if (yyleng > 0)
        printf("%s", yytext);
}

# TODO: load/store addressing modes [x]
# TODO: special reg guards (Op)
# TODO: handle small branch resizing

# --- loads and stores ---

LdSt = LdOpt | LdNoOpt | LdMulti | StOpt | StNoOpt | StMulti

LdOpt = l:LD rt:REG COMMA addr:AddrOpt {
    ldst(l, rt, addr, true);
}

LdNoOpt = l:LD_BASIC rt:REG COMMA addr:AddrNoOpt {
    ldst(l, rt, addr, true);
}

LdMulti = l:LD_MULTI rt1:REG COMMA rt2:REG COMMA addr:AddrNoOpt {
    ldstmulti(l, rt1, rt2, addr, true);
}

StOpt = l:ST rt:REG COMMA addr:AddrOpt {
    ldst(l, rt, addr, false);
}

StNoOpt = l:ST_BASIC rt:REG COMMA addr:AddrNoOpt {
    ldst(l, rt, addr, false);
}

StMulti = l:ST_MULTI rt1:REG COMMA rt2:REG COMMA addr:AddrNoOpt {
    ldstmulti(l, rt1, rt2, addr, false);
}

# Address mode transformations that use [x21, wN, uxtw].
AddrOpt = (
    # [xN, i]!
      (LB r:XREG COMMA i:IMM RB EXCLAM) {
        $$ = (Transform) {
            .guard = xasprintf("add %s, %s, %s", r.val, r.val, i.val),
            .val = xasprintf("[x21, %s, uxtw]", lo(r.val)),
        };
        tfree(r); tfree(i);
    }
    # [xN, i]
    | (LB r:XREG COMMA i:IMM RB) {
        char* ival = i.val;
        if (i.val[0] == '#')
            ival++;
        int ii = atoi(ival);
        if (ii > 4096) {
            $$ = (Transform) {
                .guard = xasprintf("add x18, x21, %s, uxtw", lo(r.val)),
                .val = xasprintf("[x18, %s]", i.val),
            };
        } else {
            $$ = (Transform) {
                .guard = xasprintf("add x22, %s, %s", r.val, i.val),
                .val = strdup("[x21, w22, uxtw]"),
            };
        }
        tfree(r); tfree(i);
    }
    # [xN], i
    | (LB r:XREG RB COMMA i:IMM) {
        $$ = (Transform) {
            .val = xasprintf("[x21, %s, uxtw]", lo(r.val)),
            .post = xasprintf("add %s, %s, %s", r.val, r.val, i.val),
        };
        tfree(r); tfree(i);
    }
    # [xN]
    | (LB r:XREG RB) {
        $$ = (Transform) {
            .val = xasprintf("[x21, %s, uxtw]", lo(r.val)),
        };
        tfree(r);
    }
    # [xN, xM, ...]
    | (LB r1:XREG COMMA r2:REG COMMA m:ADDR_MOD RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x22, %s, %s, %s", r1.val, r2.val, m.val),
            .val = strdup("[x21, w22, uxtw]"),
        };
        tfree(r1); tfree(r2); tfree(m);
    }
    # [xN, xM]
    | (LB r1:XREG COMMA r2:REG RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x22, %s, %s", r1.val, r2.val),
            .val = strdup("[x21, w22, uxtw]"),
        };
        tfree(r1); tfree(r2);
    }
)

# Address mode transformations that use x18.
AddrNoOpt = (
    # [xN, i]!
      (LB r:XREG COMMA i:IMM RB EXCLAM) {
        $$ = (Transform) {
            .guard = xasprintf("add x18, x21, %s, uxtw", lo(r.val)),
            .val = xasprintf("[x18, %s]!", i.val),
            .post = xasprintf("mov %s, x18", r.val),
        };
        tfree(r); tfree(i);
    }
    # [xN, i]
    | (LB r:XREG COMMA i:IMM RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x18, x21, %s, uxtw", lo(r.val)),
            .val = xasprintf("[x18, %s]", i.val),
        };
        tfree(i); tfree(r);
    }
    # [xN], i
    | (LB r:XREG RB COMMA i:IMM) {
        $$ = (Transform) {
            .guard = xasprintf("add x18, x21, %s, uxtw", lo(r.val)),
            .val = xasprintf("[x18], %s", i.val),
            .post = xasprintf("mov %s, x18", r.val),
        };
        tfree(r); tfree(i);
    }
    # [xN]
    | (LB r:XREG RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x18, x21, %s, uxtw", lo(r.val)),
            .val = strdup("[x18]"),
        };
        tfree(r);
    }
)

# Loads/stores that have all addressing modes available.
LD = < (
      'ldrs' [bhw]
    | 'ldr' [bh]?
    | 'prfm'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

ST = < (
    'str' [bh]?
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# Loads/stores that only have basic addressing modes available.
LD_BASIC = < (
      'ldurs' [bhw]
    | 'ldur' [bh]?
    | 'ld' [ax] 'r' [bh]?
    | 'ldtrs' [bhw]?
    | 'ldtr' [bh]?
    | 'prfum'
    | 'ld' [1234]
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

ST_BASIC = < (
      'stur' [bh]?
    | 'stlr' [bh]?
    | 'sttr' [bh]?
    | 'st' [1234]
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

LD_MULTI = < (
      'ldpsw'
    | 'ldp'
    | 'ld' 'a'? 'xp'
    | 'ldnp'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

ST_MULTI = < (
      'stp'
    | 'stnp'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# special case for stores with exclusive monitor
ST_SPECIAL = < (
      'st' 'l'? 'xr'
    | 'st' 'l'? 'xp'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# --- branches ---

Branch = b:BRANCH r:XREG {
    printf("add x18, x21, %s, uxtw\n", lo(r.val));
    printf("%s x18\n", b.val);
    tfree(r); tfree(b);
}

BRANCH = < ('br' | 'blr') > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# --- syscalls ---

Syscall = < 'svc' - '#0' > - {
    printf("str x30, [sp, #16]!\n");
    printf("ldr x30, [x21]\n");
    printf("blr x30\n");
    printf("ldr x30, [sp], 16\n");
    printf("add x30, x21, w30, uxtw\n");
}

# --- reserved register modification ---

ModSpecial = i:MODINST res:RESREG COMMA r:REMAINDER {
    printf("%s x22, %s\n", i.val, r.val);
    printf("add %s, x21, w22, uxtw\n", res.val);
    tfree(r); tfree(res); tfree(i);
}

ModLR = ModNormalLR | ModMultiLR1 | ModMultiLR2

ModNormalLR = 'ldr' - 'x30' - COMMA r:REMAINDER {
    printf("ldr x22, %s\n", r.val);
    printf("add x30, x21, w22, uxtw\n");
    tfree(r);
}

ModMultiLR1 = 'ldp' - 'x30' - COMMA reg:REG COMMA r:REMAINDER {
    printf("ldp x22, %s, %s\n", reg.val, r.val);
    printf("add x30, x21, w22, uxtw\n");
    tfree(r); tfree(reg);
}

ModMultiLR2 = 'ldp' - reg:REG COMMA 'x30' - COMMA r:REMAINDER {
    printf("ldp %s, x22, %s\n", reg.val, r.val);
    printf("add x30, x21, w22, uxtw\n");
    tfree(r); tfree(reg);
}


MODINST = < (
      'add'
    | 'sub'
    | 'mov'
    | 'and'
    | 'orr'
    | 'eor'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

REMAINDER = < (!EOL .)* > { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# --- everything else ---

Any = < (!EOL .)* > { printf("%s\n", yytext); }

Label = < ID ':' > - {
    printf("%s", yytext);
}

# --- common definitions ---

Op = r:XREG { $$ = (Transform) { .val = r.val } }

IMM = < IMM_RAW > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

IMM_RAW = (
    ('#' -)? 
    (
          [-0-9]+
        | BALANCED
        | RELOC
    )
)

BALANCED = LP ([^()] | BALANCED)* RP

RELOC = ':' ID ':' ID

ADDR_MOD = < (
      ('lsl' - IMM_RAW)
    | ([su] 'xtw' - IMM_RAW?)
    | ('sxtx' - IMM_RAW?)
) > - {
    $$ = (Transform) { .val = strndup(yytext, yyleng) }
}

RESREG = < (
      'x21'
    | 'x18'
    | 'x30'
    | 'sp'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

REG = XREG | WREG | SIMD_REG

SIMD_REG = < (
      (LC ([^}])* RC (LB (!RB .)* RB)?)
    | ID
    ) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

XREG = < 'x' r:REGNUM > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

WREG = < 'w' r:REGNUM > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

REGNUM = (
      '10'
    | '11'
    | '12'
    | '13'
    | '14'
    | '15'
    | '16'
    | '17'
    | '18'
    | '19'
    | '20'
    | '21'
    | '22'
    | '23'
    | '24'
    | '25'
    | '26'
    | '27'
    | '28'
    | '29'
    | '30'
    | '0'
    | '1'
    | '2'
    | '3'
    | '4'
    | '5'
    | '6'
    | '7'
    | '8'
    | '9'
    | 'zr'
)

ID = [a-zA-Z_.][-a-zA-Z0-9_.+]*

COMMA   = ',' -
EXCLAM  = '!' -
LB      = '[' -
RB      = ']' -
LP      = '(' -
RP      = ')' -
LC      = '{' -
RC      = '}' -
-       = [ \t]*
EOL     = '\n' | '\r\n' | '\r'

%%

int main() {
    while (yyparse())
        ;
    return 0;
}
