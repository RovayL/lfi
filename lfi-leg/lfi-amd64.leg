%{
#include <stdio.h>
#include <util.h>
#include <assert.h>
#include <keystone/keystone.h>

#include "amd64.h"
#include "ht.h"
#include "op.h"

extern FILE* input;
extern FILE* output;

typedef struct transform {
    char* val;
    char* valrbx;
    char* guard;
    char* guardrbx;
    char* post;
} Transform;

static void
tfree(Transform t)
{
    free(t.val);
    free(t.guard);
    free(t.post);
}

#define YYSTYPE Transform

#define YY_INPUT(buf, result, max_size)      \
{                                            \
    result = fread(buf, 1, max_size, input); \
}                                            \
%}

Top = Insn* !.

Insn = INDENT Label? (
      FnDirective
    | Directive
    | Lea
    | Triple1
    | Triple2
    | StoreH
    | Store
    | LoadH
    | Load
    | Access
    | Branch
    | CallInd
    | CallIndMem
    | Call
    | Syscall
    | COMMENT
    | Any
) COMMENT? (EOL | ';')+

COMMENT = (('//' | '#') (!EOL .)* | ('/*' (!'*/' .)* '*/'))

INDENT = < [ \t]* > {
    // if (yyleng > 0)
        // printf("%s", yytext);
}

# --- loads and stores ---

Lea = l:LEA a:AddrNoMod COMMA r:REG {
    mkinsn("%s %s, %s\n", l.val, a.val, r.val);
}

LEA = < ('lea' [wlq]?) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

Access = m:NAME a:Addr {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s\n", m.val, a.val);
}

LoadH = m:NAME a:Addr COMMA r:HREG {
    if (!a.guardrbx)
        mkinsn("%s %s, %s\n", m.val, a.val, r.val);
    else {
        mkinsn("%s\n", a.guardrbx);
        mkinsn("%s %s, %s\n", m.val, a.valrbx, r.val);
        mkinsn("%s\n", a.post);
    }
}

Load = m:NAME a:Addr COMMA r:ITEM {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s, %s\n", m.val, a.val, r.val);
}

StoreH = m:NAME r:HREG COMMA a:Addr {
    if (!a.guardrbx)
        mkinsn("%s %s, %s\n", m.val, r.val, a.val);
    else {
        mkinsn("%s\n", a.guardrbx);
        mkinsn("%s %s, %s\n", m.val, r.val, a.valrbx);
        mkinsn("%s\n", a.post);
    }
}

Store = m:NAME r:ITEM COMMA a:Addr {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s, %s\n", m.val, r.val, a.val);
}

Triple1 = m:NAME r1:ITEM COMMA a:Addr COMMA r2:ITEM {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s, %s, %s\n", m.val, r1.val, a.val, r2.val);
}

Triple2 = m:NAME r1:ITEM COMMA r2:ITEM COMMA a:Addr {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s, %s, %s\n", m.val, a.val, r1.val, r2.val);
}

Addr = (
    # (%rxx)
      (LP r:XREG_NOSP RP) {
        $$ = (Transform) {
            .val = xasprintf("%%gs:(%s)", lo(r.val)),
        }
    }
    # imm(%rxx)
    | (i:IMM LP r:XREG_NOSP RP) {
        $$ = (Transform) {
            .val = xasprintf("%%gs:%s(%s)", i.val, lo(r.val)),
        }
    }
    # imm(...)
    | (i:IMM b:AddrRegReg) {
        $$ = (Transform) {
            .guard = xasprintf("leaq %s%s, %%r15", i.val, b.val),
            .val = xasprintf("%%gs:(%%r15d)"),
            .guardrbx = xasprintf("mov %%rbx, %%r15\nleaq %s%s, %%rbx", i.val, b.val),
            .valrbx = xasprintf("%%gs:(%%ebx)"),
            .post = strdup("mov %r15, %rbx"),
        }
    }
    | (i:IMM b:AddrRegRegImm) {
        $$ = (Transform) {
            .guard = xasprintf("leaq %s%s, %%r15", i.val, b.val),
            .val = xasprintf("%%gs:(%%r15d)"),
            .guardrbx = xasprintf("mov %%rbx, %%r15\nleaq %s%s, %%rbx", i.val, b.val),
            .valrbx = xasprintf("%%gs:(%%ebx)"),
            .post = strdup("mov %r15, %rbx"),
        }
    }
    # (...)
    | (b:AddrRegReg) {
        $$ = (Transform) {
            .guard = xasprintf("leaq %s, %%r15", b.val),
            .val = xasprintf("%%gs:(%%r15d)"),
            .guardrbx = xasprintf("mov %%rbx, %%r15\nleaq %s, %%rbx", b.val),
            .valrbx = xasprintf("%%gs:(%%ebx)"),
            .post = strdup("mov %r15, %rbx"),
        }
    }
    | (b:AddrRegRegImm) {
        $$ = (Transform) {
            .guard = xasprintf("leaq %s, %%r15", b.val),
            .val = xasprintf("%%gs:(%%r15d)"),
            .guardrbx = xasprintf("mov %%rbx, %%r15\nleaq %s, %%rbx", b.val),
            .valrbx = xasprintf("%%gs:(%%ebx)"),
            .post = strdup("mov %r15, %rbx"),
        }
    }
)

AddrRegReg = '(' (!AddrReg r1:REG) COMMA (!AddrReg r2:REG) ')' {
    $$ = (Transform) { .val = xasprintf("(%s, %s)", r1.val, r2.val) }
}
AddrRegRegImm = '(' (!AddrReg r1:REG) COMMA (!AddrReg r2:REG) (COMMA i:IMM) ')' {
    $$ = (Transform) { .val = xasprintf("(%s, %s, %s)", r1.val, r2.val, i.val) }
}

AddrReg = 'rsp' | 'rip'

AddrNoMod = (
    # imm(...)
      (i:IMM b:BALANCED) {
        $$ = (Transform) {
            .val = xasprintf("%s%s", i.val, b.val),
        }
    }
    # (...)
    | (b:BALANCED) {
        $$ = (Transform) {
            .val = xasprintf("%s", b.val),
        }
    }
)

BALANCED = < BALANCED_RAW > {
    $$ = (Transform) { .val = strndup(yytext, yyleng) }
}

# --- branches ---

CallInd = 'call' 'q'? - '*' r:XREG {
    mkdirective(".p2align 4\n");
    //mkinsn("andl $0xfffffff0, %s\n", lo(r.val));
    mkinsn("orq %%gs:0x810, %s\n", r.val);
    mkinsn("callq *%s\n", r.val);
    tfree(r);
}

CallIndMem = 'call' 'q'? - '*' a:Addr {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("mov %s, %r15\n", a.val);
    mkdirective(".p2align 4\n");
    //mkinsn("andl $0xfffffff0, %%r15d\n");
    mkinsn("orq %%gs:0x810, %%r15\n");
    mkinsn("callq *%%r15\n");
    tfree(a);
}

Call = 'call' 'q'? - rest:ITEM {
    mkinsn("data16 cs nopw 0x0(%rax,%rax,1)\n"); // 11-byte nop
    mkinsn("callq %s\n", rest.val);
    tfree(rest);
}

Branch = 'jmp' 'q'? - '*' r:XREG {
    mkdirective(".p2align 4\n");
    mkinsn("andl $0xfffffff0, %s\n", lo(r.val));
    mkinsn("orq %%gs:0x810, %s\n", r.val);
    mkinsn("jmpq *%s\n", r.val);
    tfree(r);
}

Ret = 'ret' 'q'? - {
    mkdirective(".p2align 4\n");
    mkinsn("popq %%r15\n");
    //mkinsn("andl $0xfffffff0, %%r15d\n");
    mkinsn("orq %%gs:0x810, %%r15\n");
    mkinsn("jmpq *%%r15\n");
}

# --- syscalls ---

Syscall = (( 'syscall' - ) | ( 'int' - '0x80' - )) {
    mkinsn("call *%%gs:0x0\n")
}

# --- reserved register modification ---

# --- everything else ---

Any = < (!(EOL | ';') .)* > {
    if (yyleng > 0)
        mkinsn("%s\n", yytext);
}

Label = < ([0-9]+ | ID) > ':' - {
    mklabel(strndup(yytext, yyleng));
}

Directive = < '.' (!EOL .)* > - {
    mkdirective(xasprintf("%s\n", yytext));
}

FnDirective = < '.type' - ([^,])* ',' - '@function' - > {
    mkdirective(xasprintf("%s\n", yytext));
    mkdirective(".p2align 4\n");
}

NAME = < ID > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# --- common definitions ---

IMM = < IMM_RAW > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

IMM_RAW = (
    ('$' -)? 
    (
          [-0-9abcdefxABCDEF]+
        | BALANCED_RAW
        | RELOC
    )
)

BALANCED_RAW = LP ([^()] | BALANCED_RAW)* RP

RELOC = ':' ID ':' ID

XREG_NOSP = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rbp'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

REG = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rsp'
    | '%rbp'
    | '%r8d'
    | '%r9d'
    | '%r10d'
    | '%r11d'
    | '%r12d'
    | '%r13d'
    | '%r14d'
    | '%r15d'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
    | '%eax'
    | '%ecx'
    | '%edx'
    | '%ebx'
    | '%esi'
    | '%edi'
    | '%esp'
    | '%ebp'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

HREG = < '%' [abcd] 'h' > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

XREG = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rsp'
    | '%rbp'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

ID = [a-zA-Z_.][-a-zA-Z0-9_.+]*

ITEM = < [^ ,;\n\r#/]+ > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

COMMA   = ',' -
EXCLAM  = '!' -
LB      = '[' -
RB      = ']' -
LP      = '(' -
RP      = ')' -
LC      = '{' -
RC      = '}' -
-       = [ \t]*
EOL     = '\n' | '\r\n' | '\r'

%%

enum {
    FIXUP_DIST = 8000,
};

static int
dist(int a, int b)
{
    int d = a - b;
    if (d < 0)
        d = -d;
    return d;
}

static size_t
min(size_t a, size_t b)
{
    if (a < b)
        return a;
    return b;
}

static size_t
max(size_t a, size_t b)
{
    if (a > b)
        return a;
    return b;
}

size_t x64_insn_size(char*);

bool
lfigen()
{
    // while (yyparse());
    if (!yyparse())
        return false;

    ks_engine* ks;

    ks_err err = ks_open(KS_ARCH_X86, KS_MODE_64, &ks);
    if (err != KS_ERR_OK) {
        fprintf(stderr, "ERROR: failed on ks_open()\n");
        return false;
    }
    ks_option(ks, KS_OPT_SYNTAX, KS_OPT_SYNTAX_ATT);


    int bundle = 16;
    int log_bundle = 4;

    size_t curbundle = 0;
    struct op* op = ops;
    while (op) {
        if (op->insn) {
            size_t count = 0;
            size_t size_ks = 0;
            unsigned char* encode = NULL;
            ks_asm(ks, op->text, 0, &encode, &size_ks, &count);
            ks_free(encode);
            size_t size_x64 = x64_insn_size(op->text);

            size_t size = 0;
            if (size_x64 != 0 && size_ks != 0)
                size = min(size_x64, size_ks);
            else
                size = max(size_x64, size_ks);

            if (size == 0 && strncmp(op->text, "jmp", strlen("jmp")) == 0) {
                size = 5;
            }
            if (size == 0) {
                fprintf(stderr, "ERROR: cannot assemble %s\n", op->text);
                size = 15; // max instruction size
            }
            curbundle += size;
            if (curbundle > bundle) {
                fprintf(output, ".p2align %d\n", log_bundle);
                curbundle = curbundle % bundle;
            }
        } else if (strncmp(op->text, ".p2align 4", strlen(".p2align 4")) == 0) {
            curbundle = 0;
        }
        fprintf(output, "%s", op->text);
        op = op->next;
    }

    ks_close(ks);

    return true;
}
