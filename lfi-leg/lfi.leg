%{
#include <stdio.h>
#include <arm64.h>
#include <util.h>

typedef struct transform {
    char* val;
    char* guard;
    char* post;
} Transform;

static void
tfree(Transform t)
{
    free(t.val);
    free(t.guard);
    free(t.post);
}

#define YYSTYPE Transform
%}

Insn = INDENT Label? (
      LdSt
    | Branch
    | Syscall
    | ModSP
    | Any
) EOL

INDENT = < [ \t]* > {
    if (yyleng > 0)
        printf("%s", yytext);
}

# TODO: load/store addressing modes [x]
# TODO: special reg guards (Op)
# TODO: handle small branch resizing

# --- loads and stores ---

LdSt = LdStOpt | LdStNoOpt | LdStMulti

LdStOpt = l:LDST rt:REG COMMA addr:AddrOpt {
    if (addr.guard)
        printf("%s\n", addr.guard);
    printf("%s %s, %s\n", l.val, rt.val, addr.val);
    if (addr.post)
        printf("%s\n", addr.post);
    tfree(l); tfree(rt); tfree(addr);
}

LdStNoOpt = l:LDST_BASIC rt:REG COMMA addr:AddrNoOpt {
    printf("%s\n", addr.guard);
    printf("%s %s, %s\n", l.val, rt.val, addr.val);
    tfree(l); tfree(rt); tfree(addr);
}

LdStMulti = l:LDST_MULTI rt1:REG COMMA rt2:REG COMMA addr:AddrNoOpt {
    printf("%s\n", addr.guard);
    printf("%s %s, %s, %s\n", l.val, rt1.val, rt2.val, addr.val);
    tfree(l); tfree(rt1); tfree(rt2); tfree(addr);
}

# Address mode transformations that use [x21, wN, uxtw].
AddrOpt = (
      (LB r:XREG COMMA i:IMM RB EXCLAM) {
        $$ = (Transform) {
            .guard = xasprintf("add %s, %s, %s", r.val, r.val, i.val),
            .val = xasprintf("[x21, %s, uxtw]", lo(r.val)),
        };
        tfree(r); tfree(i);
    }
    | (LB r:XREG COMMA i:IMM RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x22, %s, %s", r.val, i.val),
            .val = strdup("[x21, w22, uxtw]"),
        };
        tfree(r); tfree(i);
    }
    | (LB r:XREG RB COMMA i:IMM) {
        $$ = (Transform) {
            .val = xasprintf("[x21, %s, uxtw]", lo(r.val)),
            .post = xasprintf("add %s, %s, %s", r.val, r.val, i.val),
        };
        tfree(r); tfree(i);
    }
    | (LB r:XREG RB) {
        $$ = (Transform) {
            .val = xasprintf("[x21, %s, uxtw]", lo(r.val)),
        };
        tfree(r);
    }
    | (LB r1:XREG COMMA r2:REG COMMA m:ADDR_MOD RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x22, %s, %s, %s", r1.val, r2.val, m.val),
            .val = strdup("[x21, w22, uxtw]"),
        };
        tfree(r1); tfree(r2); tfree(m);
    }
    | (LB r1:XREG COMMA r2:REG RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x22, %s, %s", r1.val, r2.val),
            .val = strdup("[x21, w22, uxtw]"),
        };
        tfree(r1); tfree(r2);
    }
)

# Address mode transformations that use x18.
AddrNoOpt = (
      (LB r:XREG COMMA i:IMM RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x18, x21, %s, uxtw", lo(r.val)),
            .val = xasprintf("[x18, %s]", i.val),
        };
        tfree(i); tfree(r);
    }
    | (LB r:XREG RB) {
        $$ = (Transform) {
            .guard = xasprintf("add x18, x21, %s, uxtw", lo(r.val)),
            .val = strdup("[x18]"),
        };
        tfree(r);
    }
)

# Loads/stores that have all addressing modes available.
LDST = < (
      'ldrs' [bhw]
    | 'ldr' [bh]?
    | 'prfm'
    | 'str' [bh]?
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# Loads/stores that only have basic addressing modes available.
LDST_BASIC = < (
      'ldurs' [bhw]
    | 'ldur' [bh]?
    | 'stur' [bh]?
    | 'ld' [ax] 'r' [bh]?
    | 'ldtrs' [bhw]?
    | 'ldtr' [bh]?
    | 'stlr' [bh]?
    | 'sttr' [bh]?
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

LDST_MULTI = < (
      'ldpsw'
    | 'ldp'
    | 'stp'
    | 'ld' 'a'? 'xp'
    | 'ldnp'
    | 'st' 'l'? 'xr' # not really a multi-store since one arg is the exclusive monitor result
    | 'st' 'l'? 'xp' # note: has 3 args
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# --- branches ---

Branch = b:BRANCH r:XREG {
    printf("add x18, x21, %s, uxtw\n", r.val);
    printf("%s x18\n", b.val);
    tfree(r); tfree(b);
}

BRANCH = < ('br' | 'blr') > - { $$.val = strndup(yytext, yyleng) }

# --- syscalls ---

Syscall = < 'svc' - '#0' > - {
    printf("str x30, [sp, #16]!\n");
    printf("ldr x30, [x21]\n");
    printf("blr x30\n");
    printf("ldr x30, [sp], 16\n");
    printf("add x30, x21, w30, uxtw\n");
}

# --- reserved register modification ---

ModSP = 'add' - 'sp' - COMMA r:XREG COMMA o:Op {
    printf("add x22, %s, %s\n", r.val, o.val);
    printf("add sp, x21, w22, uxtw\n");
    tfree(r); tfree(o);
}

# --- everything else ---

Any = < (!EOL .)* > { printf("%s\n", yytext); }

Label = < ID ':' > - {
    printf("%s", yytext);
}

# --- common definitions ---

Op = r:XREG { $$.val = r.val }

IMM = < IMM_RAW > - { $$.val = strndup(yytext, yyleng) }

IMM_RAW = (
    ('#' -)? 
    (
          [0-9]+
        | BALANCED
        | RELOC
    )
)

BALANCED = LP ([^()] | BALANCED)* RP

RELOC = ':' ID ':' ID

ADDR_MOD = < (
      ('lsl' - IMM_RAW)
    | ([su] 'xtw' - IMM_RAW?)
    | ('sxtx' - IMM_RAW?)
) > - {
    $$.val = strndup(yytext, yyleng)
}

RESREG = < (
      'x21'
    | 'x18'
    | 'x30'
    | 'sp'
) > - { $$.val = strndup(yytext, yyleng) }

REG = XREG | WREG

XREG = < 'x' r:REGNUM > { $$.val = strndup(yytext, yyleng) }

WREG = < 'w' r:REGNUM > { $$.val = strndup(yytext, yyleng) }

REGNUM = (
      '0'
    | '1'
    | '2'
    | '3'
    | '4'
    | '5'
    | '6'
    | '7'
    | '8'
    | '9'
    | '10'
    | '11'
    | '12'
    | '13'
    | '14'
    | '15'
    | '16'
    | '17'
    | '18'
    | '19'
    | '20'
    | '21'
    | '22'
    | '23'
    | '24'
    | '25'
    | '26'
    | '27'
    | '28'
    | '29'
    | '30'
) -

ID = [a-zA-Z_.][-a-zA-Z0-9_.]*

COMMA   = ',' -
EXCLAM  = '!' -
LB      = '[' -
RB      = ']' -
LP      = '(' -
RP      = ')' -
-       = [ \t]*
EOL     = '\n' | '\r\n' | '\r'

%%

int main() {
    while (yyparse())
        ;
    return 0;
}
