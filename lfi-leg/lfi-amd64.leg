%{
#include <stdio.h>
#include <util.h>
#include <assert.h>

#include "amd64.h"
#include "ht.h"
#include "op.h"

extern FILE* input;
extern FILE* output;

typedef struct transform {
    char* val;
    char* valrbx;
    char* guard;
    char* guardrbx;
    char* post;
} Transform;

static void
tfree(Transform t)
{
    free(t.val);
    free(t.guard);
    free(t.post);
}

#define YYSTYPE Transform

#define YY_INPUT(buf, result, max_size)      \
{                                            \
    result = fread(buf, 1, max_size, input); \
}                                            \
%}

Top = Insn* !.

Insn = INDENT Label? (
      FnDirective
    | Directive
    | Lea
    | Triple1
    | Triple2
    | StoreH
    | Store
    | LoadH
    | Load
    | Access
    | Branch
    | CallInd
    | Call
    | Syscall
    | COMMENT
    | Any
) COMMENT? (EOL | ';')+

COMMENT = (('//' | '#') (!EOL .)* | ('/*' (!'*/' .)* '*/'))

INDENT = < [ \t]* > {
    // if (yyleng > 0)
        // printf("%s", yytext);
}

# --- loads and stores ---

Lea = l:LEA a:AddrNoMod COMMA r:REG {
    mkinsn("%s %s, %s\n", l.val, a.val, r.val);
}

LEA = < ('lea' [wlq]?) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

Access = m:NAME a:Addr {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s\n", m.val, a.val);
}

LoadH = m:NAME a:Addr COMMA r:HREG {
    if (!a.guardrbx)
        mkinsn("%s %s, %s\n", m.val, a.val, r.val);
    else {
        mkinsn("%s\n", a.guardrbx);
        mkinsn("%s %s, %s\n", m.val, a.valrbx, r.val);
        mkinsn("%s\n", a.post);
    }
}

Load = m:NAME a:Addr COMMA r:ITEM {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s, %s\n", m.val, a.val, r.val);
}

StoreH = m:NAME r:HREG COMMA a:Addr {
    if (!a.guardrbx)
        mkinsn("%s %s, %s\n", m.val, r.val, a.val);
    else {
        mkinsn("%s\n", a.guardrbx);
        mkinsn("%s %s, %s\n", m.val, r.val, a.valrbx);
        mkinsn("%s\n", a.post);
    }
}

Store = m:NAME r:ITEM COMMA a:Addr {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s, %s\n", m.val, r.val, a.val);
}

Triple1 = m:NAME r1:ITEM COMMA a:Addr COMMA r2:ITEM {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s, %s, %s\n", m.val, r1.val, a.val, r2.val);
}

Triple2 = m:NAME r1:ITEM COMMA r2:ITEM COMMA a:Addr {
    if (a.guard)
        mkinsn("%s\n", a.guard);
    mkinsn("%s %s, %s, %s\n", m.val, a.val, r1.val, r2.val);
}

Addr = (
    # (%rxx)
      (LP r:XREG_NOSP RP) {
        $$ = (Transform) {
            .val = xasprintf("%%gs:(%s)", lo(r.val)),
        }
    }
    # imm(%rxx)
    | (i:IMM LP r:XREG_NOSP RP) {
        $$ = (Transform) {
            .val = xasprintf("%%gs:%s(%s)", i.val, lo(r.val)),
        }
    }
    # imm(...)
    | (i:IMM b:AddrRegReg) {
        $$ = (Transform) {
            .guard = xasprintf("lea %s%s, %%r15", i.val, b.val),
            .val = xasprintf("%%gs:(%%r15d)"),
            .guardrbx = xasprintf("mov %%rbx, %%r15\nlea %s%s, %%rbx", i.val, b.val),
            .valrbx = xasprintf("%%gs:(%%ebx)"),
            .post = strdup("mov %r15, %rbx"),
        }
    }
    | (i:IMM b:AddrRegRegImm) {
        $$ = (Transform) {
            .guard = xasprintf("lea %s%s, %%r15", i.val, b.val),
            .val = xasprintf("%%gs:(%%r15d)"),
            .guardrbx = xasprintf("mov %%rbx, %%r15\nlea %s%s, %%rbx", i.val, b.val),
            .valrbx = xasprintf("%%gs:(%%ebx)"),
            .post = strdup("mov %r15, %rbx"),
        }
    }
    # (...)
    | (b:AddrRegReg) {
        $$ = (Transform) {
            .guard = xasprintf("lea %s, %%r15", b.val),
            .val = xasprintf("%%gs:(%%r15d)"),
            .guardrbx = xasprintf("mov %%rbx, %%r15\nlea %s, %%rbx", b.val),
            .valrbx = xasprintf("%%gs:(%%ebx)"),
            .post = strdup("mov %r15, %rbx"),
        }
    }
    | (b:AddrRegRegImm) {
        $$ = (Transform) {
            .guard = xasprintf("lea %s, %%r15", b.val),
            .val = xasprintf("%%gs:(%%r15d)"),
            .guardrbx = xasprintf("mov %%rbx, %%r15\nlea %s, %%rbx", b.val),
            .valrbx = xasprintf("%%gs:(%%ebx)"),
            .post = strdup("mov %r15, %rbx"),
        }
    }
)

AddrRegReg = '(' (!AddrReg r1:REG) COMMA (!AddrReg r2:REG) ')' {
    $$ = (Transform) { .val = xasprintf("(%s, %s)", r1.val, r2.val) }
}
AddrRegRegImm = '(' (!AddrReg r1:REG) COMMA (!AddrReg r2:REG) (COMMA i:IMM) ')' {
    $$ = (Transform) { .val = xasprintf("(%s, %s, %s)", r1.val, r2.val, i.val) }
}

AddrReg = 'rsp' | 'rip'

AddrNoMod = (
    # imm(...)
      (i:IMM b:BALANCED) {
        $$ = (Transform) {
            .val = xasprintf("%s%s", i.val, b.val),
        }
    }
    # (...)
    | (b:BALANCED) {
        $$ = (Transform) {
            .val = xasprintf("%s", b.val),
        }
    }
)

BALANCED = < BALANCED_RAW > {
    $$ = (Transform) { .val = strndup(yytext, yyleng) }
}

# --- branches ---

CallInd = 'call' - '*' r:XREG {
    mkdirective(".p2align 4\n");
    mkinsn("and $0xfffffff0, %s\n", lo(r.val));
    mkinsn("or %%gs:0x810, %s\n", r.val);
    mkinsn("call *%s\n", r.val);
    tfree(r);
}

Call = 'call' - rest:ITEM {
    mkinsn("call %s\n", rest.val);
    tfree(rest);
}

Branch = 'jmp' - '*' r:XREG {
    mkdirective(".p2align 4\n");
    mkinsn("and $0xfffffff0, %s\n", lo(r.val));
    mkinsn("or %%gs:0x810, %s\n", r.val);
    mkinsn("jmp *%s\n", r.val);
    tfree(r);
}

Ret = 'ret' - {
    mkdirective(".p2align 4\n");
    mkinsn("popq %%rdi\n");
    mkinsn("and $0xfffffff0, %%edi\n");
    mkinsn("or %%gs:0x810, %%rdi\n");
    mkinsn("jmp *%%rdi\n");
}

# --- syscalls ---

Syscall = (( 'syscall' - ) | ( 'int' - '0x80' - )) {
    mkinsn("call *%%gs:0x0\n")
}

# --- reserved register modification ---

# --- everything else ---

Any = < (!(EOL | ';') .)* > {
    if (yyleng > 0)
        mkinsn("%s\n", yytext);
}

Label = < ID > ':' - {
    mklabel(strndup(yytext, yyleng));
}

Directive = < '.' (!EOL .)* > - {
    mkdirective(xasprintf("%s\n", yytext));
}

FnDirective = < '.type' - ([^,])* ',' - '@function' - > {
    mkdirective(xasprintf("%s\n", yytext));
    mkdirective(".p2align 4\n");
}

NAME = < ID > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

# --- common definitions ---

IMM = < IMM_RAW > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

IMM_RAW = (
    ('$' -)? 
    (
          [-0-9abcdefxABCDEF]+
        | BALANCED_RAW
        | RELOC
    )
)

BALANCED_RAW = LP ([^()] | BALANCED_RAW)* RP

RELOC = ':' ID ':' ID

XREG_NOSP = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rbp'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

REG = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rsp'
    | '%rbp'
    | '%r8d'
    | '%r9d'
    | '%r10d'
    | '%r11d'
    | '%r12d'
    | '%r13d'
    | '%r14d'
    | '%r15d'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
    | '%eax'
    | '%ecx'
    | '%edx'
    | '%ebx'
    | '%esi'
    | '%edi'
    | '%esp'
    | '%ebp'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

HREG = < '%' [abcd] 'h' > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

XREG = < (
      '%rax'
    | '%rcx'
    | '%rdx'
    | '%rbx'
    | '%rsi'
    | '%rdi'
    | '%rsp'
    | '%rbp'
    | '%r8'
    | '%r9'
    | '%r10'
    | '%r11'
    | '%r12'
    | '%r13'
    | '%r14'
    | '%r15'
) > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

ID = [a-zA-Z_.][-a-zA-Z0-9_.+]*

ITEM = < [^ ,;\n\r#/]+ > - { $$ = (Transform) { .val = strndup(yytext, yyleng) } }

COMMA   = ',' -
EXCLAM  = '!' -
LB      = '[' -
RB      = ']' -
LP      = '(' -
RP      = ')' -
LC      = '{' -
RC      = '}' -
-       = [ \t]*
EOL     = '\n' | '\r\n' | '\r'

%%

enum {
    FIXUP_DIST = 8000,
};

static int
dist(int a, int b)
{
    int d = a - b;
    if (d < 0)
        d = -d;
    return d;
}

bool
lfigen()
{
    // while (yyparse());
    if (!yyparse())
        return false;

    struct ht labels;
    int icount = 0;
    int r = ht_alloc(&labels, 1024);
    assert(r == 0);

    struct op* op = ops;
    while (op) {
        if (op->label != NULL) {
            ht_put(&labels, op->label, icount);
        }
        icount += op->insn ? 1 : 0;
        op = op->next;
    }

    icount = 0;
    op = ops;
    while (op) {
        if (op->shortbr) {
            bool found;
            int tcount = ht_get(&labels, op->target, &found);
            if (found && op->replace && dist(tcount, icount) > FIXUP_DIST) {
                fprintf(output, "%s", op->replace);
            } else {
                fprintf(output, "%s", op->text);
            }
        } else {
            fprintf(output, "%s", op->text);
        }
        icount += op->insn ? 1 : 0;
        op = op->next;
    }

    return true;
}
