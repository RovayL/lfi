reserved registers:
x20: always contains a valid address
x21: segment ID
x22: system call entrypoint
x23: scratch register

sp: special
fp: special (TODO)

TODO:
make this transformation
add sp, sp, #n
->
add w14, wsp, #n
add sp, x21, x14

requires that x14 is a reserved 32-bit-only register

load/store transformations:
    ldr _, [x0]
    ->
    ldr _, [x21, w0, uxtw]

    ldr _, [x0, #n]
    ->
    add x20, x21, w0, uxtw
    ldr _, [x20, #n]
    -- OR -- (if range analysis didn't help)
    add x23, x0, #n
    ldr _, [x21, w23, uxtw]

    ldr _, [x0], #n
    ->
    ldr _, [x21, w0, uxtw]
    add x0, x0, #n

    ldr _, [x0, #n]!
    ->
    add x0, x0, #n
    ldr _, [x21, w0, uxtw]

    ldr _, [x0, x1]
    ->
    add x20, x21, w0, uxtw
    ldr _, [x20, w1, sxtw]
    -- OR -- (if range analysis didn't help)
    add x23, x0, x1
    ldr _, [x21, w23, uxtw]

    ldr _, [x0, x1, lsl #n]
    ->
    add x20, x21, w0, uxtw
    and x23, x1, 0x0000_0000_0fff_ffff
    ldr _, [x20, w23, sxtw #n]
    -- OR -- (if range analysis didn't help)
    add x23, x0, x1, lsl #n
    ldr _, [x21, w23, uxtw]

    ldp _, _, [x0]
    ->
    add x20, x21, w0, uxtw
    ldp _, _, [x20]
    
    mov x20, x0
    bfi x20, x21, #64, #32
    ldp _, _, [x20]

    ldur _, [x0, #n]
    ->
    add x20, x21, w0, uxtw
    ldur _, [x20, #n]
    -- OR -- (if range analysis didn't help)
    add x23, x0, #n
    ldr _, [x21, w23, uxtw]

    TODO:
    ldur, stur
    staxr, ldaxr, etc...
    ld1, st1, etc...

branch transformations:
    br x0
    ->
    add x20, x21, w0, uxtw
    br x20

    blr x0
    ->
    add x20, x21, w0, uxtw
    blr x20


alternative sandbox:
* movk (possible to implement a version that doesn't reserve any registers and
  thus works on unmodified static-pie XoM binaries?)
* version that uses BFI and can support larger/smaller boxes
